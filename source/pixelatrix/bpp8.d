module pixelatrix.bpp8;

import pixelatrix.common;

/++
+ 8 bit per pixel tile format with palette. Each row has its bitplanes stored
+ adjacent to one another. Commonly used by the SNES.
+/
alias Packed8BPP = Packed!8;
///
@safe pure unittest {
	import std.string : representation;
	const data = (cast(const(Packed8BPP)[])import("bpp8-sample1.bin").representation)[0];
	const ubyte[8][8] finaldata = [
		[0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF],
		[0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10],
		[0xEF, 0xCD, 0xAB, 0x89, 0x67, 0x45, 0x23, 0x01],
		[0x10, 0x32, 0x54, 0x76, 0x98, 0xBA, 0xDC, 0xFE],
		[0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF],
		[0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10],
		[0xEF, 0xCD, 0xAB, 0x89, 0x67, 0x45, 0x23, 0x01],
		[0x10, 0x32, 0x54, 0x76, 0x98, 0xBA, 0xDC, 0xFE]
	];
	assert(data.pixelMatrix() == finaldata);
	assert(data[1, 2] == 0xCD);
	{
		Packed8BPP data2;
		data2[1, 0] = 0x42;
		assert(data2[1, 0] == 0x42);
		assert(data2.raw[1] == 0x42);
	}
}
/++
+ 8 bit per pixel tile format with palette. Each row has its bitplanes stored
+ adjacent to one another. Commonly used by the SNES.
+/
alias Intertwined8BPP = Intertwined!8;
///
@safe pure unittest {
	import std.string : representation;
	const data = (cast(const(Intertwined8BPP)[])import("bpp8-sample2.bin").representation)[0];
	const ubyte[8][8] finaldata = [
		[0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF],
		[0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10],
		[0xEF, 0xCD, 0xAB, 0x89, 0x67, 0x45, 0x23, 0x01],
		[0x10, 0x32, 0x54, 0x76, 0x98, 0xBA, 0xDC, 0xFE],
		[0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF],
		[0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10],
		[0xEF, 0xCD, 0xAB, 0x89, 0x67, 0x45, 0x23, 0x01],
		[0x10, 0x32, 0x54, 0x76, 0x98, 0xBA, 0xDC, 0xFE]
	];
	assert(data.pixelMatrix() == finaldata);
	assert(data[1, 2] == 0xCD);
	{
		Intertwined8BPP data2;
		data2[1, 0] = 0x42;
		assert(data2[1, 0] == 0x42);
	}
}
