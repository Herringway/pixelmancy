module pixelmancy.tiles.bpp8;

import pixelmancy.tiles.common;

/++
+ 8 bit per pixel tile format with palette. Each row has its bitplanes stored
+ adjacent to one another. Commonly used by the SNES.
+/
alias Packed8BPP = Packed!8;
///
@safe pure unittest {
	import std.string : representation;
	const data = (cast(const(Packed8BPP)[])import("bpp8-sample1.bin").representation)[0];
	const ubyte[8][8] finaldata = [
		[0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF],
		[0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10],
		[0xEF, 0xCD, 0xAB, 0x89, 0x67, 0x45, 0x23, 0x01],
		[0x10, 0x32, 0x54, 0x76, 0x98, 0xBA, 0xDC, 0xFE],
		[0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF],
		[0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10],
		[0xEF, 0xCD, 0xAB, 0x89, 0x67, 0x45, 0x23, 0x01],
		[0x10, 0x32, 0x54, 0x76, 0x98, 0xBA, 0xDC, 0xFE]
	];
	assert(data.pixelMatrix() == finaldata);
	assert(data[1, 2] == 0xCD);
	{
		Packed8BPP data2;
		data2[1, 0] = 0x42;
		assert(data2[1, 0] == 0x42);
		assert(data2.raw[1] == 0x42);
	}
	{
		Packed8BPP data2;
		data2[] = 0x52;
		assert(data2[0, 0] == 0x52);
		assert(data2[4, 0] == 0x52);
		assert(data2[0, 4] == 0x52);
		assert(data2[7, 7] == 0x52);
	}
	{
		Packed8BPP data2;
		data2[] = 0x11;
		data2[1 .. 4, 0] = 0x52;
		assert(data2[1, 0] == 0x52);
		assert(data2[3, 0] == 0x52);
		assert(data2[4, 0] == 0x11);
	}
	{
		Packed8BPP data2;
		data2[] = 0x44;
		data2[4 .. $, 0 .. $] = 0x77;
		assert(data2[4, 0] == 0x77);
		assert(data2[4, 6] == 0x77);
		assert(data2[$ - 1, $ - 1] == 0x77);
		assert(data2[2, 0] == 0x44);
		assert(data2[4 .. $, 0 .. $][0, 0] == 0x77);
		assert(data2[4 .. $, 0][0, 0] == 0x77);
		assert(data2[4, 0 .. $][0, 0] == 0x77);
		foreach (x, y, p; data2[4 .. $, 0 .. $]) {
			assert(p == 0x77);
		}
		const d3 = data2;
		foreach (x, y, p; d3[4 .. $, 0 .. $]) {
			assert(p == 0x77);
		}
	}
}
/++
+ 8 bit per pixel tile format with palette. Each row has its bitplanes stored
+ adjacent to one another. Commonly used by the SNES.
+/
alias Intertwined8BPP = Intertwined!8;
///
@safe pure unittest {
	import std.string : representation;
	const data = (cast(const(Intertwined8BPP)[])import("bpp8-sample2.bin").representation)[0];
	const ubyte[8][8] finaldata = [
		[0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF],
		[0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10],
		[0xEF, 0xCD, 0xAB, 0x89, 0x67, 0x45, 0x23, 0x01],
		[0x10, 0x32, 0x54, 0x76, 0x98, 0xBA, 0xDC, 0xFE],
		[0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF],
		[0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10],
		[0xEF, 0xCD, 0xAB, 0x89, 0x67, 0x45, 0x23, 0x01],
		[0x10, 0x32, 0x54, 0x76, 0x98, 0xBA, 0xDC, 0xFE]
	];
	assert(data.pixelMatrix() == finaldata);
	assert(data[1, 2] == 0xCD);
	{
		Intertwined8BPP data2;
		data2[1, 0] = 0x42;
		assert(data2[1, 0] == 0x42);
	}
}
